import sys


# Задание 1.

# Написать генератор нечётных чисел от 1 до n (включительно), используя ключевое слово yield, например:
# >>> odd_to_15 = odd_nums(15)
# >>> next(odd_to_15)
# 1
# >>> next(odd_to_15)
# 3
# ...
# >>> next(odd_to_15)
# 15
# >>> next(odd_to_15)
# ...StopIteration...


def odd_numb_gen(n):  # аргумент ф-ции будет число по которое генерируем
    for i in range(1, n + 1):  # создаем цикл от 1 до n и прибавляем 1, чтобы было включительно
        if i % 2 != 0:  # проверяем на нечетность (при делении на 2 остаток не равен 0)
            yield i  # возвращаем число, которое соответствует условию


odd_numb_gen_10 = odd_numb_gen(10)  # необходимо генератор записать в глобальную переменную результат работы ф-ции
print(next(odd_numb_gen_10))  # печатаем получившиеся значения
print(next(odd_numb_gen_10))
print(next(odd_numb_gen_10))
print(next(odd_numb_gen_10))
print(next(odd_numb_gen_10))


# Задание 3

# Есть два списка:
# tutors = ['Иван', 'Анастасия', 'Петр', 'Сергей', 'Дмитрий', 'Борис', 'Елена']
# klasses = ['9А', '7В', '9Б', '9В', '8Б', '10А', '10Б', '9А']
#
# Необходимо реализовать генератор, возвращающий кортежи вида (<tutor>, <klass>), например:
# ('Иван', '9А')
# ('Анастасия', '7В')
# ...
#
# Количество генерируемых кортежей не должно быть больше длины списка tutors.
# Если в списке klasses меньше элементов, чем в списке tutors, необходимо вывести последние кортежи
# в виде: (<tutor>, None), например:
# ('Станислав', None)
#
# Доказать, что вы создали именно генератор.
# Проверить его работу вплоть до истощения.
# Подумать, в каких ситуациях генератор даст эффект.


tutors = ['Иван', 'Анастасия', 'Петр', 'Сергей', 'Дмитрий', 'Борис', 'Елена']
klasses = ['9А', '7В', '9Б', '9В', '8Б', '10А', '10Б', '9А']  # элементов в списке классов больше, чем в списке имен


def name_klass_gen():
    i = 0  # счетчик классов
    j = 0  # счетчик имен
    while i < len(klasses):  # пока элементы в списке классы не закончатся
        if i >= len(tutors):  # если эл. больше или равны количеств. эл. в списке имен, то
            yield None, klasses[i]  # вернуть None вместо имени и класс
            i += 1
            j += 1
            break
        else:
            yield tutors[j], klasses[i]  # в остальных случаях выводим имя и класс из списков
            i += 1
            j += 1


for gen in name_klass_gen():  # проверяем полностью работу функции "до истощения"
    print(gen)

print(type(name_klass_gen()))  # доказательство, что это именно генератор


# Задание 4

# Представлен список чисел. Необходимо вывести те его элементы, значения которых больше предыдущего, например:
# src = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55]
# result = [12, 44, 4, 10, 78, 123]
#
#
# Подсказка: использовать возможности python, изученные на уроке.
# Подумайте, как можно сделать оптимизацию кода по памяти, по скорости.


src = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55]

res = [src[i] for i in range(1, len(src)) if src[i] > src[i-1]]  # обращение к эл. по индексу, создаем с помощью
# range список с элементами из src. Если эл. больше предыдщуего эл, то добавляется в новый список
print(res)

print(sys.getsizeof(res))  # доказтельство, что сделана оптимиз. по памяти
print(sys.getsizeof(src))


# Задание 5

# Представлен список чисел.
# Определить элементы списка, не имеющие повторений.
# Сформировать из этих элементов список с сохранением порядка их следования в исходном списке, например:
# src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# result = [23, 1, 3, 10, 4, 11]
#
# Подсказка: напишите сначала решение «в лоб». Потом подумайте об оптимизации.


unknown_numb = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]

# счетчик вхожд. эл. в список, но отрабатывает неверно, не совсем понимаю
result = [unknown_numb[j] for j in range(len(unknown_numb)) if unknown_numb.count(j) == 1]
print(result)
